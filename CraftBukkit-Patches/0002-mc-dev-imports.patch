From 796630458aee1aab9b870fece5ead790d7f0274b Mon Sep 17 00:00:00 2001
From: md_5 <md_5@live.com.au>
Date: Sun, 1 Dec 2013 15:10:48 +1100
Subject: [PATCH] mc-dev imports


diff --git a/src/main/java/net/minecraft/server/BiomeDecorator.java b/src/main/java/net/minecraft/server/BiomeDecorator.java
new file mode 100644
index 0000000..b048d6c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BiomeDecorator.java
@@ -0,0 +1,279 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BiomeDecorator {
+
+    protected World a;
+    protected Random b;
+    protected int c;
+    protected int d;
+    protected WorldGenerator e = new WorldGenClay(4);
+    protected WorldGenerator f;
+    protected WorldGenerator g;
+    protected WorldGenerator h;
+    protected WorldGenerator i;
+    protected WorldGenerator j;
+    protected WorldGenerator k;
+    protected WorldGenerator l;
+    protected WorldGenerator m;
+    protected WorldGenerator n;
+    protected WorldGenerator o;
+    protected WorldGenFlowers p;
+    protected WorldGenerator q;
+    protected WorldGenerator r;
+    protected WorldGenerator s;
+    protected WorldGenerator t;
+    protected WorldGenerator u;
+    protected WorldGenerator v;
+    protected int w;
+    protected int x;
+    protected int y;
+    protected int z;
+    protected int A;
+    protected int B;
+    protected int C;
+    protected int D;
+    protected int E;
+    protected int F;
+    protected int G;
+    protected int H;
+    public boolean I;
+
+    public BiomeDecorator() {
+        this.f = new WorldGenSand(Blocks.SAND, 7);
+        this.g = new WorldGenSand(Blocks.GRAVEL, 6);
+        this.h = new WorldGenMinable(Blocks.DIRT, 32);
+        this.i = new WorldGenMinable(Blocks.GRAVEL, 32);
+        this.j = new WorldGenMinable(Blocks.COAL_ORE, 16);
+        this.k = new WorldGenMinable(Blocks.IRON_ORE, 8);
+        this.l = new WorldGenMinable(Blocks.GOLD_ORE, 8);
+        this.m = new WorldGenMinable(Blocks.REDSTONE_ORE, 7);
+        this.n = new WorldGenMinable(Blocks.DIAMOND_ORE, 7);
+        this.o = new WorldGenMinable(Blocks.LAPIS_ORE, 6);
+        this.p = new WorldGenFlowers(Blocks.YELLOW_FLOWER);
+        this.q = new WorldGenFlowers(Blocks.BROWN_MUSHROOM);
+        this.r = new WorldGenFlowers(Blocks.RED_MUSHROOM);
+        this.s = new WorldGenHugeMushroom();
+        this.t = new WorldGenReed();
+        this.u = new WorldGenCactus();
+        this.v = new WorldGenWaterLily();
+        this.y = 2;
+        this.z = 1;
+        this.E = 1;
+        this.F = 3;
+        this.G = 1;
+        this.I = true;
+    }
+
+    public void a(World world, Random random, BiomeBase biomebase, int i, int j) {
+        if (this.a != null) {
+            throw new RuntimeException("Already decorating!!");
+        } else {
+            this.a = world;
+            this.b = random;
+            this.c = i;
+            this.d = j;
+            this.a(biomebase);
+            this.a = null;
+            this.b = null;
+        }
+    }
+
+    protected void a(BiomeBase biomebase) {
+        this.a();
+
+        int i;
+        int j;
+        int k;
+
+        for (i = 0; i < this.F; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.f.a(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.G; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.e.a(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        for (i = 0; i < this.E; ++i) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            this.g.a(this.a, this.b, j, this.a.i(j, k), k);
+        }
+
+        i = this.x;
+        if (this.b.nextInt(10) == 0) {
+            ++i;
+        }
+
+        int l;
+        int i1;
+
+        for (j = 0; j < i; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.a.getHighestBlockYAt(k, l);
+            WorldGenTreeAbstract worldgentreeabstract = biomebase.a(this.b);
+
+            worldgentreeabstract.a(1.0D, 1.0D, 1.0D);
+            if (worldgentreeabstract.a(this.a, this.b, k, i1, l)) {
+                worldgentreeabstract.b(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.H; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            this.s.a(this.a, this.b, k, this.a.getHighestBlockYAt(k, l), l);
+        }
+
+        for (j = 0; j < this.y; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) + 32);
+            String s = biomebase.a(this.b, k, i1, l);
+            BlockFlowers blockflowers = BlockFlowers.e(s);
+
+            if (blockflowers.getMaterial() != Material.AIR) {
+                this.p.a(blockflowers, BlockFlowers.f(s));
+                this.p.a(this.a, this.b, k, i1, l);
+            }
+        }
+
+        for (j = 0; j < this.z; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            WorldGenerator worldgenerator = biomebase.b(this.b);
+
+            worldgenerator.a(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.A; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            (new WorldGenDeadBush(Blocks.DEAD_BUSH)).a(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.w; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+
+            for (i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2); i1 > 0 && this.a.isEmpty(k, i1 - 1, l); --i1) {
+                ;
+            }
+
+            this.v.a(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < this.B; ++j) {
+            if (this.b.nextInt(4) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.a.getHighestBlockYAt(k, l);
+                this.q.a(this.a, this.b, k, i1, l);
+            }
+
+            if (this.b.nextInt(8) == 0) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.d + this.b.nextInt(16) + 8;
+                i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+                this.r.a(this.a, this.b, k, i1, l);
+            }
+        }
+
+        if (this.b.nextInt(4) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            this.q.a(this.a, this.b, j, l, k);
+        }
+
+        if (this.b.nextInt(8) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            this.r.a(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.C; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.t.a(this.a, this.b, k, i1, l);
+        }
+
+        for (j = 0; j < 10; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.t.a(this.a, this.b, k, i1, l);
+        }
+
+        if (this.b.nextInt(32) == 0) {
+            j = this.c + this.b.nextInt(16) + 8;
+            k = this.d + this.b.nextInt(16) + 8;
+            l = this.b.nextInt(this.a.getHighestBlockYAt(j, k) * 2);
+            (new WorldGenPumpkin()).a(this.a, this.b, j, l, k);
+        }
+
+        for (j = 0; j < this.D; ++j) {
+            k = this.c + this.b.nextInt(16) + 8;
+            l = this.d + this.b.nextInt(16) + 8;
+            i1 = this.b.nextInt(this.a.getHighestBlockYAt(k, l) * 2);
+            this.u.a(this.a, this.b, k, i1, l);
+        }
+
+        if (this.I) {
+            for (j = 0; j < 50; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(248) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.WATER)).a(this.a, this.b, k, l, i1);
+            }
+
+            for (j = 0; j < 20; ++j) {
+                k = this.c + this.b.nextInt(16) + 8;
+                l = this.b.nextInt(this.b.nextInt(this.b.nextInt(240) + 8) + 8);
+                i1 = this.d + this.b.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.LAVA)).a(this.a, this.b, k, l, i1);
+            }
+        }
+    }
+
+    protected void a(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k - j) + j;
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.a(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void b(int i, WorldGenerator worldgenerator, int j, int k) {
+        for (int l = 0; l < i; ++l) {
+            int i1 = this.c + this.b.nextInt(16);
+            int j1 = this.b.nextInt(k) + this.b.nextInt(k) + (j - k);
+            int k1 = this.d + this.b.nextInt(16);
+
+            worldgenerator.a(this.a, this.b, i1, j1, k1);
+        }
+    }
+
+    protected void a() {
+        this.a(20, this.h, 0, 256);
+        this.a(10, this.i, 0, 256);
+        this.a(20, this.j, 0, 128);
+        this.a(20, this.k, 0, 64);
+        this.a(2, this.l, 0, 32);
+        this.a(8, this.m, 0, 16);
+        this.a(1, this.n, 0, 16);
+        this.b(1, this.o, 16, 16);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
new file mode 100644
index 0000000..9e1ce2f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -0,0 +1,79 @@
+package net.minecraft.server;
+
+public class BlockAnvil extends BlockFalling {
+
+    public static final String[] a = new String[] { "intact", "slightlyDamaged", "veryDamaged"};
+    private static final String[] N = new String[] { "anvil_top_damaged_0", "anvil_top_damaged_1", "anvil_top_damaged_2"};
+
+    protected BlockAnvil() {
+        super(Material.HEAVY);
+        this.g(0);
+        this.a(CreativeModeTab.c);
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        int l = MathHelper.floor((double) (entityliving.yaw * 4.0F / 360.0F) + 0.5D) & 3;
+        int i1 = world.getData(i, j, k) >> 2;
+
+        ++l;
+        l %= 4;
+        if (l == 0) {
+            world.setData(i, j, k, 2 | i1 << 2, 2);
+        }
+
+        if (l == 1) {
+            world.setData(i, j, k, 3 | i1 << 2, 2);
+        }
+
+        if (l == 2) {
+            world.setData(i, j, k, 0 | i1 << 2, 2);
+        }
+
+        if (l == 3) {
+            world.setData(i, j, k, 1 | i1 << 2, 2);
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            entityhuman.openAnvil(i, j, k);
+            return true;
+        }
+    }
+
+    public int b() {
+        return 35;
+    }
+
+    public int getDropData(int i) {
+        return i >> 2;
+    }
+
+    public void updateShape(IBlockAccess iblockaccess, int i, int j, int k) {
+        int l = iblockaccess.getData(i, j, k) & 3;
+
+        if (l != 3 && l != 1) {
+            this.a(0.125F, 0.0F, 0.0F, 0.875F, 1.0F, 1.0F);
+        } else {
+            this.a(0.0F, 0.0F, 0.125F, 1.0F, 1.0F, 0.875F);
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {
+        entityfallingblock.a(true);
+    }
+
+    public void a(World world, int i, int j, int k, int l) {
+        world.triggerEffect(1022, i, j, k, 0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
new file mode 100644
index 0000000..3287d77
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -0,0 +1,109 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+
+public class BlockBrewingStand extends BlockContainer {
+
+    private Random a = new Random();
+
+    public BlockBrewingStand() {
+        super(Material.ORE);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 25;
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityBrewingStand();
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public void a(World world, int i, int j, int k, AxisAlignedBB axisalignedbb, List list, Entity entity) {
+        this.a(0.4375F, 0.0F, 0.4375F, 0.5625F, 0.875F, 0.5625F);
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+        this.g();
+        super.a(world, i, j, k, axisalignedbb, list, entity);
+    }
+
+    public void g() {
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 0.125F, 1.0F);
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (world.isStatic) {
+            return true;
+        } else {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) world.getTileEntity(i, j, k);
+
+            if (tileentitybrewingstand != null) {
+                entityhuman.openBrewingStand(tileentitybrewingstand);
+            }
+
+            return true;
+        }
+    }
+
+    public void postPlace(World world, int i, int j, int k, EntityLiving entityliving, ItemStack itemstack) {
+        if (itemstack.hasName()) {
+            ((TileEntityBrewingStand) world.getTileEntity(i, j, k)).a(itemstack.getName());
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        if (tileentity instanceof TileEntityBrewingStand) {
+            TileEntityBrewingStand tileentitybrewingstand = (TileEntityBrewingStand) tileentity;
+
+            for (int i1 = 0; i1 < tileentitybrewingstand.getSize(); ++i1) {
+                ItemStack itemstack = tileentitybrewingstand.getItem(i1);
+
+                if (itemstack != null) {
+                    float f = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f1 = this.a.nextFloat() * 0.8F + 0.1F;
+                    float f2 = this.a.nextFloat() * 0.8F + 0.1F;
+
+                    while (itemstack.count > 0) {
+                        int j1 = this.a.nextInt(21) + 10;
+
+                        if (j1 > itemstack.count) {
+                            j1 = itemstack.count;
+                        }
+
+                        itemstack.count -= j1;
+                        EntityItem entityitem = new EntityItem(world, (double) ((float) i + f), (double) ((float) j + f1), (double) ((float) k + f2), new ItemStack(itemstack.getItem(), j1, itemstack.getData()));
+                        float f3 = 0.05F;
+
+                        entityitem.motX = (double) ((float) this.a.nextGaussian() * f3);
+                        entityitem.motY = (double) ((float) this.a.nextGaussian() * f3 + 0.2F);
+                        entityitem.motZ = (double) ((float) this.a.nextGaussian() * f3);
+                        world.addEntity(entityitem);
+                    }
+                }
+            }
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.BREWING_STAND;
+    }
+
+    public boolean M() {
+        return true;
+    }
+
+    public int g(World world, int i, int j, int k, int l) {
+        return Container.b((IInventory) world.getTileEntity(i, j, k));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockFlowerPot.java b/src/main/java/net/minecraft/server/BlockFlowerPot.java
new file mode 100644
index 0000000..ca6f4f0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockFlowerPot.java
@@ -0,0 +1,186 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockFlowerPot extends BlockContainer {
+
+    public BlockFlowerPot() {
+        super(Material.ORIENTABLE);
+        this.g();
+    }
+
+    public void g() {
+        float f = 0.375F;
+        float f1 = f / 2.0F;
+
+        this.a(0.5F - f1, 0.0F, 0.5F - f1, 0.5F + f1, f, 0.5F + f1);
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public int b() {
+        return 33;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        ItemStack itemstack = entityhuman.inventory.getItemInHand();
+
+        if (itemstack != null && itemstack.getItem() instanceof ItemBlock) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                if (tileentityflowerpot.a() != null) {
+                    return false;
+                } else {
+                    Block block = Block.a(itemstack.getItem());
+
+                    if (!this.a(block, itemstack.getData())) {
+                        return false;
+                    } else {
+                        tileentityflowerpot.a(itemstack.getItem(), itemstack.getData());
+                        tileentityflowerpot.update();
+                        if (!world.setData(i, j, k, itemstack.getData(), 2)) {
+                            world.notify(i, j, k);
+                        }
+
+                        if (!entityhuman.abilities.canInstantlyBuild && --itemstack.count <= 0) {
+                            entityhuman.inventory.setItem(entityhuman.inventory.itemInHandIndex, (ItemStack) null);
+                        }
+
+                        return true;
+                    }
+                }
+            } else {
+                return false;
+            }
+        } else {
+            return false;
+        }
+    }
+
+    private boolean a(Block block, int i) {
+        return block != Blocks.YELLOW_FLOWER && block != Blocks.RED_ROSE && block != Blocks.CACTUS && block != Blocks.BROWN_MUSHROOM && block != Blocks.RED_MUSHROOM && block != Blocks.SAPLING && block != Blocks.DEAD_BUSH ? block == Blocks.LONG_GRASS && i == 2 : true;
+    }
+
+    public int getDropData(World world, int i, int j, int k) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        return tileentityflowerpot != null && tileentityflowerpot.a() != null ? tileentityflowerpot.b() : 0;
+    }
+
+    public boolean canPlace(World world, int i, int j, int k) {
+        return super.canPlace(world, i, j, k) && World.a((IBlockAccess) world, i, j - 1, k);
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (!World.a((IBlockAccess) world, i, j - 1, k)) {
+            this.b(world, i, j, k, world.getData(i, j, k), 0);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void remove(World world, int i, int j, int k, Block block, int l) {
+        TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+        if (tileentityflowerpot != null && tileentityflowerpot.a() != null) {
+            this.a(world, i, j, k, new ItemStack(tileentityflowerpot.a(), 1, tileentityflowerpot.b()));
+        }
+
+        super.remove(world, i, j, k, block, l);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityHuman entityhuman) {
+        super.a(world, i, j, k, l, entityhuman);
+        if (entityhuman.abilities.canInstantlyBuild) {
+            TileEntityFlowerPot tileentityflowerpot = this.e(world, i, j, k);
+
+            if (tileentityflowerpot != null) {
+                tileentityflowerpot.a(Item.d(0), 0);
+            }
+        }
+    }
+
+    public Item getDropType(int i, Random random, int j) {
+        return Items.FLOWER_POT;
+    }
+
+    private TileEntityFlowerPot e(World world, int i, int j, int k) {
+        TileEntity tileentity = world.getTileEntity(i, j, k);
+
+        return tileentity != null && tileentity instanceof TileEntityFlowerPot ? (TileEntityFlowerPot) tileentity : null;
+    }
+
+    public TileEntity a(World world, int i) {
+        Object object = null;
+        byte b0 = 0;
+
+        switch (i) {
+        case 1:
+            object = Blocks.RED_ROSE;
+            b0 = 0;
+            break;
+
+        case 2:
+            object = Blocks.YELLOW_FLOWER;
+            break;
+
+        case 3:
+            object = Blocks.SAPLING;
+            b0 = 0;
+            break;
+
+        case 4:
+            object = Blocks.SAPLING;
+            b0 = 1;
+            break;
+
+        case 5:
+            object = Blocks.SAPLING;
+            b0 = 2;
+            break;
+
+        case 6:
+            object = Blocks.SAPLING;
+            b0 = 3;
+            break;
+
+        case 7:
+            object = Blocks.RED_MUSHROOM;
+            break;
+
+        case 8:
+            object = Blocks.BROWN_MUSHROOM;
+            break;
+
+        case 9:
+            object = Blocks.CACTUS;
+            break;
+
+        case 10:
+            object = Blocks.DEAD_BUSH;
+            break;
+
+        case 11:
+            object = Blocks.LONG_GRASS;
+            b0 = 2;
+            break;
+
+        case 12:
+            object = Blocks.SAPLING;
+            b0 = 4;
+            break;
+
+        case 13:
+            object = Blocks.SAPLING;
+            b0 = 5;
+        }
+
+        return new TileEntityFlowerPot(Item.getItemOf((Block) object), b0);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
new file mode 100644
index 0000000..e943676
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -0,0 +1,80 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class BlockTNT extends Block {
+
+    public BlockTNT() {
+        super(Material.TNT);
+        this.a(CreativeModeTab.d);
+    }
+
+    public void onPlace(World world, int i, int j, int k) {
+        super.onPlace(world, i, j, k);
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public void doPhysics(World world, int i, int j, int k, Block block) {
+        if (world.isBlockIndirectlyPowered(i, j, k)) {
+            this.postBreak(world, i, j, k, 1);
+            world.setAir(i, j, k);
+        }
+    }
+
+    public int a(Random random) {
+        return 1;
+    }
+
+    public void wasExploded(World world, int i, int j, int k, Explosion explosion) {
+        if (!world.isStatic) {
+            EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), explosion.c());
+
+            entitytntprimed.fuseTicks = world.random.nextInt(entitytntprimed.fuseTicks / 4) + entitytntprimed.fuseTicks / 8;
+            world.addEntity(entitytntprimed);
+        }
+    }
+
+    public void postBreak(World world, int i, int j, int k, int l) {
+        this.a(world, i, j, k, l, (EntityLiving) null);
+    }
+
+    public void a(World world, int i, int j, int k, int l, EntityLiving entityliving) {
+        if (!world.isStatic) {
+            if ((l & 1) == 1) {
+                EntityTNTPrimed entitytntprimed = new EntityTNTPrimed(world, (double) ((float) i + 0.5F), (double) ((float) j + 0.5F), (double) ((float) k + 0.5F), entityliving);
+
+                world.addEntity(entitytntprimed);
+                world.makeSound(entitytntprimed, "game.tnt.primed", 1.0F, 1.0F);
+            }
+        }
+    }
+
+    public boolean interact(World world, int i, int j, int k, EntityHuman entityhuman, int l, float f, float f1, float f2) {
+        if (entityhuman.bE() != null && entityhuman.bE().getItem() == Items.FLINT_AND_STEEL) {
+            this.a(world, i, j, k, 1, entityhuman);
+            world.setAir(i, j, k);
+            entityhuman.bE().damage(1, entityhuman);
+            return true;
+        } else {
+            return super.interact(world, i, j, k, entityhuman, l, f, f1, f2);
+        }
+    }
+
+    public void a(World world, int i, int j, int k, Entity entity) {
+        if (entity instanceof EntityArrow && !world.isStatic) {
+            EntityArrow entityarrow = (EntityArrow) entity;
+
+            if (entityarrow.isBurning()) {
+                this.a(world, i, j, k, 1, entityarrow.shooter instanceof EntityLiving ? (EntityLiving) entityarrow.shooter : null);
+                world.setAir(i, j, k);
+            }
+        }
+    }
+
+    public boolean a(Explosion explosion) {
+        return false;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/CommandDispatcher.java b/src/main/java/net/minecraft/server/CommandDispatcher.java
new file mode 100644
index 0000000..4c21643
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandDispatcher.java
@@ -0,0 +1,94 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+
+public class CommandDispatcher extends CommandHandler implements ICommandDispatcher {
+
+    public CommandDispatcher() {
+        this.a(new CommandTime());
+        this.a(new CommandGamemode());
+        this.a(new CommandDifficulty());
+        this.a(new CommandGamemodeDefault());
+        this.a(new CommandKill());
+        this.a(new CommandToggleDownfall());
+        this.a(new CommandWeather());
+        this.a(new CommandXp());
+        this.a(new CommandTp());
+        this.a(new CommandGive());
+        this.a(new CommandEffect());
+        this.a(new CommandEnchant());
+        this.a(new CommandMe());
+        this.a(new CommandSeed());
+        this.a(new CommandHelp());
+        this.a(new CommandDebug());
+        this.a(new CommandTell());
+        this.a(new CommandSay());
+        this.a(new CommandSpawnpoint());
+        this.a(new CommandSetWorldSpawn());
+        this.a(new CommandGamerule());
+        this.a(new CommandClear());
+        this.a(new CommandTestFor());
+        this.a(new CommandSpreadPlayers());
+        this.a(new CommandPlaySound());
+        this.a(new CommandScoreboard());
+        this.a(new CommandAchievement());
+        this.a(new CommandSummon());
+        this.a(new CommandSetBlock());
+        this.a(new CommandTestForBlock());
+        this.a(new CommandTellRaw());
+        if (MinecraftServer.getServer().W()) {
+            this.a(new CommandOp());
+            this.a(new CommandDeop());
+            this.a(new CommandStop());
+            this.a(new CommandSaveAll());
+            this.a(new CommandSaveOff());
+            this.a(new CommandSaveOn());
+            this.a(new CommandBanIp());
+            this.a(new CommandPardonIP());
+            this.a(new CommandBan());
+            this.a(new CommandBanList());
+            this.a(new CommandPardon());
+            this.a(new CommandKick());
+            this.a(new CommandList());
+            this.a(new CommandWhitelist());
+            this.a(new CommandIdleTimeout());
+            this.a(new CommandNetstat());
+        } else {
+            this.a(new CommandPublish());
+        }
+
+        CommandAbstract.a((ICommandDispatcher) this);
+    }
+
+    public void a(ICommandListener icommandlistener, ICommand icommand, int i, String s, Object... aobject) {
+        boolean flag = true;
+
+        if (icommandlistener instanceof CommandBlockListenerAbstract && !MinecraftServer.getServer().worldServer[0].getGameRules().getBoolean("commandBlockOutput")) {
+            flag = false;
+        }
+
+        ChatMessage chatmessage = new ChatMessage("chat.type.admin", new Object[] { icommandlistener.getName(), new ChatMessage(s, aobject)});
+
+        chatmessage.getChatModifier().setColor(EnumChatFormat.GRAY);
+        chatmessage.getChatModifier().setItalic(Boolean.valueOf(true));
+        if (flag) {
+            Iterator iterator = MinecraftServer.getServer().getPlayerList().players.iterator();
+
+            while (iterator.hasNext()) {
+                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+                if (entityplayer != icommandlistener && MinecraftServer.getServer().getPlayerList().isOp(entityplayer.getName()) && icommand.canUse(entityplayer) && (!(icommandlistener instanceof RemoteControlCommandListener) || MinecraftServer.getServer().m())) {
+                    entityplayer.sendMessage(chatmessage);
+                }
+            }
+        }
+
+        if (icommandlistener != MinecraftServer.getServer()) {
+            MinecraftServer.getServer().sendMessage(chatmessage);
+        }
+
+        if ((i & 1) != 1) {
+            icommandlistener.sendMessage(new ChatMessage(s, aobject));
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
new file mode 100644
index 0000000..90a2a80
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -0,0 +1,306 @@
+package net.minecraft.server;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import net.minecraft.util.org.apache.commons.lang3.ObjectUtils;
+
+public class DataWatcher {
+
+    private final Entity a;
+    private boolean b = true;
+    private static final HashMap c = new HashMap();
+    private final Map d = new HashMap();
+    private boolean e;
+    private ReadWriteLock f = new ReentrantReadWriteLock();
+
+    public DataWatcher(Entity entity) {
+        this.a = entity;
+    }
+
+    public void a(int i, Object object) {
+        Integer integer = (Integer) c.get(object.getClass());
+
+        if (integer == null) {
+            throw new IllegalArgumentException("Unknown data type: " + object.getClass());
+        } else if (i > 31) {
+            throw new IllegalArgumentException("Data value id is too big with " + i + "! (Max is " + 31 + ")");
+        } else if (this.d.containsKey(Integer.valueOf(i))) {
+            throw new IllegalArgumentException("Duplicate id value for " + i + "!");
+        } else {
+            WatchableObject watchableobject = new WatchableObject(integer.intValue(), i, object);
+
+            this.f.writeLock().lock();
+            this.d.put(Integer.valueOf(i), watchableobject);
+            this.f.writeLock().unlock();
+            this.b = false;
+        }
+    }
+
+    public void a(int i, int j) {
+        WatchableObject watchableobject = new WatchableObject(j, i, null);
+
+        this.f.writeLock().lock();
+        this.d.put(Integer.valueOf(i), watchableobject);
+        this.f.writeLock().unlock();
+        this.b = false;
+    }
+
+    public byte getByte(int i) {
+        return ((Byte) this.i(i).b()).byteValue();
+    }
+
+    public short getShort(int i) {
+        return ((Short) this.i(i).b()).shortValue();
+    }
+
+    public int getInt(int i) {
+        return ((Integer) this.i(i).b()).intValue();
+    }
+
+    public float getFloat(int i) {
+        return ((Float) this.i(i).b()).floatValue();
+    }
+
+    public String getString(int i) {
+        return (String) this.i(i).b();
+    }
+
+    public ItemStack getItemStack(int i) {
+        return (ItemStack) this.i(i).b();
+    }
+
+    private WatchableObject i(int i) {
+        this.f.readLock().lock();
+
+        WatchableObject watchableobject;
+
+        try {
+            watchableobject = (WatchableObject) this.d.get(Integer.valueOf(i));
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Getting synched entity data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Synched entity data");
+
+            crashreportsystemdetails.a("Data ID", Integer.valueOf(i));
+            throw new ReportedException(crashreport);
+        }
+
+        this.f.readLock().unlock();
+        return watchableobject;
+    }
+
+    public void watch(int i, Object object) {
+        WatchableObject watchableobject = this.i(i);
+
+        if (ObjectUtils.notEqual(object, watchableobject.b())) {
+            watchableobject.a(object);
+            this.a.i(i);
+            watchableobject.a(true);
+            this.e = true;
+        }
+    }
+
+    public void h(int i) {
+        WatchableObject.a(this.i(i), true);
+        this.e = true;
+    }
+
+    public boolean a() {
+        return this.e;
+    }
+
+    public static void a(List list, PacketDataSerializer packetdataserializer) {
+        if (list != null) {
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                a(packetdataserializer, watchableobject);
+            }
+        }
+
+        packetdataserializer.writeByte(127);
+    }
+
+    public List b() {
+        ArrayList arraylist = null;
+
+        if (this.e) {
+            this.f.readLock().lock();
+            Iterator iterator = this.d.values().iterator();
+
+            while (iterator.hasNext()) {
+                WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+                if (watchableobject.d()) {
+                    watchableobject.a(false);
+                    if (arraylist == null) {
+                        arraylist = new ArrayList();
+                    }
+
+                    arraylist.add(watchableobject);
+                }
+            }
+
+            this.f.readLock().unlock();
+        }
+
+        this.e = false;
+        return arraylist;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) {
+        this.f.readLock().lock();
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            WatchableObject watchableobject = (WatchableObject) iterator.next();
+
+            a(packetdataserializer, watchableobject);
+        }
+
+        this.f.readLock().unlock();
+        packetdataserializer.writeByte(127);
+    }
+
+    public List c() {
+        ArrayList arraylist = null;
+
+        this.f.readLock().lock();
+
+        WatchableObject watchableobject;
+
+        for (Iterator iterator = this.d.values().iterator(); iterator.hasNext(); arraylist.add(watchableobject)) {
+            watchableobject = (WatchableObject) iterator.next();
+            if (arraylist == null) {
+                arraylist = new ArrayList();
+            }
+        }
+
+        this.f.readLock().unlock();
+        return arraylist;
+    }
+
+    private static void a(PacketDataSerializer packetdataserializer, WatchableObject watchableobject) {
+        int i = (watchableobject.c() << 5 | watchableobject.a() & 31) & 255;
+
+        packetdataserializer.writeByte(i);
+        switch (watchableobject.c()) {
+        case 0:
+            packetdataserializer.writeByte(((Byte) watchableobject.b()).byteValue());
+            break;
+
+        case 1:
+            packetdataserializer.writeShort(((Short) watchableobject.b()).shortValue());
+            break;
+
+        case 2:
+            packetdataserializer.writeInt(((Integer) watchableobject.b()).intValue());
+            break;
+
+        case 3:
+            packetdataserializer.writeFloat(((Float) watchableobject.b()).floatValue());
+            break;
+
+        case 4:
+            try {
+                packetdataserializer.a((String) watchableobject.b());
+            } catch (java.io.IOException ex) {
+                throw new RuntimeException(ex);
+            }
+            break;
+
+        case 5:
+            ItemStack itemstack = (ItemStack) watchableobject.b();
+
+            packetdataserializer.a(itemstack);
+            break;
+
+        case 6:
+            ChunkCoordinates chunkcoordinates = (ChunkCoordinates) watchableobject.b();
+
+            packetdataserializer.writeInt(chunkcoordinates.x);
+            packetdataserializer.writeInt(chunkcoordinates.y);
+            packetdataserializer.writeInt(chunkcoordinates.z);
+        }
+    }
+
+    public static List b(PacketDataSerializer packetdataserializer) {
+        ArrayList arraylist = null;
+
+        for (byte b0 = packetdataserializer.readByte(); b0 != 127; b0 = packetdataserializer.readByte()) {
+            if (arraylist == null) {
+                arraylist = new ArrayList();
+            }
+
+            int i = (b0 & 224) >> 5;
+            int j = b0 & 31;
+            WatchableObject watchableobject = null;
+
+            switch (i) {
+            case 0:
+                watchableobject = new WatchableObject(i, j, Byte.valueOf(packetdataserializer.readByte()));
+                break;
+
+            case 1:
+                watchableobject = new WatchableObject(i, j, Short.valueOf(packetdataserializer.readShort()));
+                break;
+
+            case 2:
+                watchableobject = new WatchableObject(i, j, Integer.valueOf(packetdataserializer.readInt()));
+                break;
+
+            case 3:
+                watchableobject = new WatchableObject(i, j, Float.valueOf(packetdataserializer.readFloat()));
+                break;
+
+            case 4:
+                try {
+                    watchableobject = new WatchableObject(i, j, packetdataserializer.c(32767));
+                } catch (java.io.IOException ex) {
+                    throw new RuntimeException(ex);
+                }
+                break;
+
+            case 5:
+                watchableobject = new WatchableObject(i, j, packetdataserializer.c());
+                break;
+
+            case 6:
+                int k = packetdataserializer.readInt();
+                int l = packetdataserializer.readInt();
+                int i1 = packetdataserializer.readInt();
+
+                watchableobject = new WatchableObject(i, j, new ChunkCoordinates(k, l, i1));
+            }
+
+            arraylist.add(watchableobject);
+        }
+
+        return arraylist;
+    }
+
+    public boolean d() {
+        return this.b;
+    }
+
+    public void e() {
+        this.e = false;
+    }
+
+    static {
+        c.put(Byte.class, Integer.valueOf(0));
+        c.put(Short.class, Integer.valueOf(1));
+        c.put(Integer.class, Integer.valueOf(2));
+        c.put(Float.class, Integer.valueOf(3));
+        c.put(String.class, Integer.valueOf(4));
+        c.put(ItemStack.class, Integer.valueOf(5));
+        c.put(ChunkCoordinates.class, Integer.valueOf(6));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
new file mode 100644
index 0000000..6e7c3a2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -0,0 +1,129 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public abstract class NBTBase {
+
+    public static final String[] a = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+
+    abstract void write(DataOutput dataoutput) throws IOException;
+
+    abstract void load(DataInput datainput, int i) throws IOException;
+
+    public abstract String toString();
+
+    public abstract byte getTypeId();
+
+    protected NBTBase() {}
+
+    protected static NBTBase createTag(byte b0) {
+        switch (b0) {
+        case 0:
+            return new NBTTagEnd();
+
+        case 1:
+            return new NBTTagByte();
+
+        case 2:
+            return new NBTTagShort();
+
+        case 3:
+            return new NBTTagInt();
+
+        case 4:
+            return new NBTTagLong();
+
+        case 5:
+            return new NBTTagFloat();
+
+        case 6:
+            return new NBTTagDouble();
+
+        case 7:
+            return new NBTTagByteArray();
+
+        case 8:
+            return new NBTTagString();
+
+        case 9:
+            return new NBTTagList();
+
+        case 10:
+            return new NBTTagCompound();
+
+        case 11:
+            return new NBTTagIntArray();
+
+        default:
+            return null;
+        }
+    }
+
+    public static String getTagName(int i) {
+        switch (i) {
+        case 0:
+            return "TAG_End";
+
+        case 1:
+            return "TAG_Byte";
+
+        case 2:
+            return "TAG_Short";
+
+        case 3:
+            return "TAG_Int";
+
+        case 4:
+            return "TAG_Long";
+
+        case 5:
+            return "TAG_Float";
+
+        case 6:
+            return "TAG_Double";
+
+        case 7:
+            return "TAG_Byte_Array";
+
+        case 8:
+            return "TAG_String";
+
+        case 9:
+            return "TAG_List";
+
+        case 10:
+            return "TAG_Compound";
+
+        case 11:
+            return "TAG_Int_Array";
+
+        case 99:
+            return "Any Numeric Tag";
+
+        default:
+            return "UNKNOWN";
+        }
+    }
+
+    public abstract NBTBase clone();
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
+
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
+
+    public int hashCode() {
+        return this.getTypeId();
+    }
+
+    protected String a_() {
+        return this.toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagByteArray.java b/src/main/java/net/minecraft/server/NBTTagByteArray.java
new file mode 100644
index 0000000..916d935
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagByteArray.java
@@ -0,0 +1,56 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagByteArray extends NBTBase {
+
+    private byte[] data;
+
+    NBTTagByteArray() {}
+
+    public NBTTagByteArray(byte[] abyte) {
+        this.data = abyte;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+        dataoutput.write(this.data);
+    }
+
+    void load(DataInput datainput, int i) throws IOException {
+        int j = datainput.readInt();
+
+        this.data = new byte[j];
+        datainput.readFully(this.data);
+    }
+
+    public byte getTypeId() {
+        return (byte) 7;
+    }
+
+    public String toString() {
+        return "[" + this.data.length + " bytes]";
+    }
+
+    public NBTBase clone() {
+        byte[] abyte = new byte[this.data.length];
+
+        System.arraycopy(this.data, 0, abyte, 0, this.data.length);
+        return new NBTTagByteArray(abyte);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagByteArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public byte[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NBTTagIntArray.java b/src/main/java/net/minecraft/server/NBTTagIntArray.java
new file mode 100644
index 0000000..49b3f14
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NBTTagIntArray.java
@@ -0,0 +1,72 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Arrays;
+
+public class NBTTagIntArray extends NBTBase {
+
+    private int[] data;
+
+    NBTTagIntArray() {}
+
+    public NBTTagIntArray(int[] aint) {
+        this.data = aint;
+    }
+
+    void write(DataOutput dataoutput) throws IOException {
+        dataoutput.writeInt(this.data.length);
+
+        for (int i = 0; i < this.data.length; ++i) {
+            dataoutput.writeInt(this.data[i]);
+        }
+    }
+
+    void load(DataInput datainput, int i) throws IOException {
+        int j = datainput.readInt();
+
+        this.data = new int[j];
+
+        for (int k = 0; k < j; ++k) {
+            this.data[k] = datainput.readInt();
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 11;
+    }
+
+    public String toString() {
+        String s = "[";
+        int[] aint = this.data;
+        int i = aint.length;
+
+        for (int j = 0; j < i; ++j) {
+            int k = aint[j];
+
+            s = s + k + ",";
+        }
+
+        return s + "]";
+    }
+
+    public NBTBase clone() {
+        int[] aint = new int[this.data.length];
+
+        System.arraycopy(this.data, 0, aint, 0, this.data.length);
+        return new NBTTagIntArray(aint);
+    }
+
+    public boolean equals(Object object) {
+        return super.equals(object) ? Arrays.equals(this.data, ((NBTTagIntArray) object).data) : false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ Arrays.hashCode(this.data);
+    }
+
+    public int[] c() {
+        return this.data;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NextTickListEntry.java b/src/main/java/net/minecraft/server/NextTickListEntry.java
new file mode 100644
index 0000000..06934a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NextTickListEntry.java
@@ -0,0 +1,60 @@
+package net.minecraft.server;
+
+public class NextTickListEntry implements Comparable {
+
+    private static long f;
+    private final Block g;
+    public int a;
+    public int b;
+    public int c;
+    public long d;
+    public int e;
+    private long h;
+
+    public NextTickListEntry(int i, int j, int k, Block block) {
+        this.h = (long) (f++);
+        this.a = i;
+        this.b = j;
+        this.c = k;
+        this.g = block;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NextTickListEntry)) {
+            return false;
+        } else {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) object;
+
+            return this.a == nextticklistentry.a && this.b == nextticklistentry.b && this.c == nextticklistentry.c && Block.a(this.g, nextticklistentry.g);
+        }
+    }
+
+    public int hashCode() {
+        return (this.a * 1024 * 1024 + this.c * 1024 + this.b) * 256;
+    }
+
+    public NextTickListEntry a(long i) {
+        this.d = i;
+        return this;
+    }
+
+    public void a(int i) {
+        this.e = i;
+    }
+
+    public int compareTo(NextTickListEntry nextticklistentry) {
+        return this.d < nextticklistentry.d ? -1 : (this.d > nextticklistentry.d ? 1 : (this.e != nextticklistentry.e ? this.e - nextticklistentry.e : (this.h < nextticklistentry.h ? -1 : (this.h > nextticklistentry.h ? 1 : 0))));
+    }
+
+    public String toString() {
+        return Block.b(this.g) + ": (" + this.a + ", " + this.b + ", " + this.c + "), " + this.d + ", " + this.e + ", " + this.h;
+    }
+
+    public Block a() {
+        return this.g;
+    }
+
+    public int compareTo(Object object) {
+        return this.compareTo((NextTickListEntry) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NibbleArray.java b/src/main/java/net/minecraft/server/NibbleArray.java
new file mode 100644
index 0000000..5d75a54
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NibbleArray.java
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class NibbleArray {
+
+    public final byte[] a;
+    private final int b;
+    private final int c;
+
+    public NibbleArray(int i, int j) {
+        this.a = new byte[i >> 1];
+        this.b = j;
+        this.c = j + 4;
+    }
+
+    public NibbleArray(byte[] abyte, int i) {
+        this.a = abyte;
+        this.b = i;
+        this.c = i + 4;
+    }
+
+    public int a(int i, int j, int k) {
+        int l = j << this.c | k << this.b | i;
+        int i1 = l >> 1;
+        int j1 = l & 1;
+
+        return j1 == 0 ? this.a[i1] & 15 : this.a[i1] >> 4 & 15;
+    }
+
+    public void a(int i, int j, int k, int l) {
+        int i1 = j << this.c | k << this.b | i;
+        int j1 = i1 >> 1;
+        int k1 = i1 & 1;
+
+        if (k1 == 0) {
+            this.a[j1] = (byte) (this.a[j1] & 240 | l & 15);
+        } else {
+            this.a[j1] = (byte) (this.a[j1] & 15 | (l & 15) << 4);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/OldChunkLoader.java b/src/main/java/net/minecraft/server/OldChunkLoader.java
new file mode 100644
index 0000000..fcb9912
--- /dev/null
+++ b/src/main/java/net/minecraft/server/OldChunkLoader.java
@@ -0,0 +1,120 @@
+package net.minecraft.server;
+
+public class OldChunkLoader {
+
+    public static OldChunk a(NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        OldChunk oldchunk = new OldChunk(i, j);
+
+        oldchunk.g = nbttagcompound.getByteArray("Blocks");
+        oldchunk.f = new OldNibbleArray(nbttagcompound.getByteArray("Data"), 7);
+        oldchunk.e = new OldNibbleArray(nbttagcompound.getByteArray("SkyLight"), 7);
+        oldchunk.d = new OldNibbleArray(nbttagcompound.getByteArray("BlockLight"), 7);
+        oldchunk.c = nbttagcompound.getByteArray("HeightMap");
+        oldchunk.b = nbttagcompound.getBoolean("TerrainPopulated");
+        oldchunk.h = nbttagcompound.getList("Entities", 10);
+        oldchunk.i = nbttagcompound.getList("TileEntities", 10);
+        oldchunk.j = nbttagcompound.getList("TileTicks", 10);
+
+        try {
+            oldchunk.a = nbttagcompound.getLong("LastUpdate");
+        } catch (ClassCastException classcastexception) {
+            oldchunk.a = (long) nbttagcompound.getInt("LastUpdate");
+        }
+
+        return oldchunk;
+    }
+
+    public static void a(OldChunk oldchunk, NBTTagCompound nbttagcompound, WorldChunkManager worldchunkmanager) {
+        nbttagcompound.setInt("xPos", oldchunk.k);
+        nbttagcompound.setInt("zPos", oldchunk.l);
+        nbttagcompound.setLong("LastUpdate", oldchunk.a);
+        int[] aint = new int[oldchunk.c.length];
+
+        for (int i = 0; i < oldchunk.c.length; ++i) {
+            aint[i] = oldchunk.c[i];
+        }
+
+        nbttagcompound.setIntArray("HeightMap", aint);
+        nbttagcompound.setBoolean("TerrainPopulated", oldchunk.b);
+        NBTTagList nbttaglist = new NBTTagList();
+
+        int j;
+
+        for (int k = 0; k < 8; ++k) {
+            boolean flag = true;
+
+            for (j = 0; j < 16 && flag; ++j) {
+                int l = 0;
+
+                while (l < 16 && flag) {
+                    int i1 = 0;
+
+                    while (true) {
+                        if (i1 < 16) {
+                            int j1 = j << 11 | i1 << 7 | l + (k << 4);
+                            byte b0 = oldchunk.g[j1];
+
+                            if (b0 == 0) {
+                                ++i1;
+                                continue;
+                            }
+
+                            flag = false;
+                        }
+
+                        ++l;
+                        break;
+                    }
+                }
+            }
+
+            if (!flag) {
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray1 = new NibbleArray(abyte.length, 4);
+                NibbleArray nibblearray2 = new NibbleArray(abyte.length, 4);
+
+                for (int k1 = 0; k1 < 16; ++k1) {
+                    for (int l1 = 0; l1 < 16; ++l1) {
+                        for (int i2 = 0; i2 < 16; ++i2) {
+                            int j2 = k1 << 11 | i2 << 7 | l1 + (k << 4);
+                            byte b1 = oldchunk.g[j2];
+
+                            abyte[l1 << 8 | i2 << 4 | k1] = (byte) (b1 & 255);
+                            nibblearray.a(k1, l1, i2, oldchunk.f.a(k1, l1 + (k << 4), i2));
+                            nibblearray1.a(k1, l1, i2, oldchunk.e.a(k1, l1 + (k << 4), i2));
+                            nibblearray2.a(k1, l1, i2, oldchunk.d.a(k1, l1 + (k << 4), i2));
+                        }
+                    }
+                }
+
+                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+                nbttagcompound1.setByte("Y", (byte) (k & 255));
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                nbttagcompound1.setByteArray("Data", nibblearray.a);
+                nbttagcompound1.setByteArray("SkyLight", nibblearray1.a);
+                nbttagcompound1.setByteArray("BlockLight", nibblearray2.a);
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        byte[] abyte1 = new byte[256];
+
+        for (int k2 = 0; k2 < 16; ++k2) {
+            for (j = 0; j < 16; ++j) {
+                abyte1[j << 4 | k2] = (byte) (worldchunkmanager.getBiome(oldchunk.k << 4 | k2, oldchunk.l << 4 | j).id & 255);
+            }
+        }
+
+        nbttagcompound.setByteArray("Biomes", abyte1);
+        nbttagcompound.set("Entities", oldchunk.h);
+        nbttagcompound.set("TileEntities", oldchunk.i);
+        if (oldchunk.j != null) {
+            nbttagcompound.set("TileTicks", oldchunk.j);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
new file mode 100644
index 0000000..c7b799a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -0,0 +1,190 @@
+package net.minecraft.server;
+
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+public class PacketPlayOutMapChunk extends Packet {
+
+    private int a;
+    private int b;
+    private int c;
+    private int d;
+    private byte[] e;
+    private byte[] buffer;
+    private boolean inflatedBuffer;
+    private int size;
+    private static byte[] buildBuffer = new byte[196864];
+
+    public PacketPlayOutMapChunk() {}
+
+    public PacketPlayOutMapChunk(Chunk chunk, boolean flag, int i) {
+        this.a = chunk.locX;
+        this.b = chunk.locZ;
+        this.inflatedBuffer = flag;
+        ChunkMap chunkmap = a(chunk, flag, i);
+        Deflater deflater = new Deflater(-1);
+
+        this.d = chunkmap.c;
+        this.c = chunkmap.b;
+
+        try {
+            this.buffer = chunkmap.a;
+            deflater.setInput(chunkmap.a, 0, chunkmap.a.length);
+            deflater.finish();
+            this.e = new byte[chunkmap.a.length];
+            this.size = deflater.deflate(this.e);
+        } finally {
+            deflater.end();
+        }
+    }
+
+    public static int c() {
+        return 196864;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+        this.a = packetdataserializer.readInt();
+        this.b = packetdataserializer.readInt();
+        this.inflatedBuffer = packetdataserializer.readBoolean();
+        this.c = packetdataserializer.readShort();
+        this.d = packetdataserializer.readShort();
+        this.size = packetdataserializer.readInt();
+        if (buildBuffer.length < this.size) {
+            buildBuffer = new byte[this.size];
+        }
+
+        packetdataserializer.readBytes(buildBuffer, 0, this.size);
+        int i = 0;
+
+        int j;
+
+        for (j = 0; j < 16; ++j) {
+            i += this.c >> j & 1;
+        }
+
+        j = 12288 * i;
+        if (this.inflatedBuffer) {
+            j += 256;
+        }
+
+        this.buffer = new byte[j];
+        Inflater inflater = new Inflater();
+
+        inflater.setInput(buildBuffer, 0, this.size);
+
+        try {
+            inflater.inflate(this.buffer);
+        } catch (DataFormatException dataformatexception) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            inflater.end();
+        }
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeInt(this.a);
+        packetdataserializer.writeInt(this.b);
+        packetdataserializer.writeBoolean(this.inflatedBuffer);
+        packetdataserializer.writeShort((short) (this.c & '\uffff'));
+        packetdataserializer.writeShort((short) (this.d & '\uffff'));
+        packetdataserializer.writeInt(this.size);
+        packetdataserializer.writeBytes(this.e, 0, this.size);
+    }
+
+    public void a(PacketPlayOutListener packetplayoutlistener) {
+        packetplayoutlistener.a(this);
+    }
+
+    public String b() {
+        return String.format("x=%d, z=%d, full=%b, sects=%d, add=%d, size=%d", new Object[] { Integer.valueOf(this.a), Integer.valueOf(this.b), Boolean.valueOf(this.inflatedBuffer), Integer.valueOf(this.c), Integer.valueOf(this.d), Integer.valueOf(this.size)});
+    }
+
+    public static ChunkMap a(Chunk chunk, boolean flag, int i) {
+        int j = 0;
+        ChunkSection[] achunksection = chunk.i();
+        int k = 0;
+        ChunkMap chunkmap = new ChunkMap();
+        byte[] abyte = buildBuffer;
+
+        if (flag) {
+            chunk.q = true;
+        }
+
+        int l;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                chunkmap.b |= 1 << l;
+                if (achunksection[l].getExtendedIdArray() != null) {
+                    chunkmap.c |= 1 << l;
+                    ++k;
+                }
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                byte[] abyte1 = achunksection[l].getIdArray();
+
+                System.arraycopy(abyte1, 0, abyte, j, abyte1.length);
+                j += abyte1.length;
+            }
+        }
+
+        NibbleArray nibblearray;
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getDataArray();
+                System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                j += nibblearray.a.length;
+            }
+        }
+
+        for (l = 0; l < achunksection.length; ++l) {
+            if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                nibblearray = achunksection[l].getEmittedLightArray();
+                System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                j += nibblearray.a.length;
+            }
+        }
+
+        if (!chunk.world.worldProvider.g) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getSkyLightArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (k > 0) {
+            for (l = 0; l < achunksection.length; ++l) {
+                if (achunksection[l] != null && (!flag || !achunksection[l].isEmpty()) && achunksection[l].getExtendedIdArray() != null && (i & 1 << l) != 0) {
+                    nibblearray = achunksection[l].getExtendedIdArray();
+                    System.arraycopy(nibblearray.a, 0, abyte, j, nibblearray.a.length);
+                    j += nibblearray.a.length;
+                }
+            }
+        }
+
+        if (flag) {
+            byte[] abyte2 = chunk.m();
+
+            System.arraycopy(abyte2, 0, abyte, j, abyte2.length);
+            j += abyte2.length;
+        }
+
+        chunkmap.a = new byte[j];
+        System.arraycopy(abyte, 0, chunkmap.a, 0, j);
+        return chunkmap;
+    }
+
+    @Override
+    public void handle(PacketListener packetlistener) {
+        this.a((PacketPlayOutListener) packetlistener);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFileCache.java b/src/main/java/net/minecraft/server/RegionFileCache.java
new file mode 100644
index 0000000..900ed68
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegionFileCache.java
@@ -0,0 +1,67 @@
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class RegionFileCache {
+
+    private static final Map a = new HashMap();
+
+    public static synchronized RegionFile a(File file1, int i, int j) {
+        File file2 = new File(file1, "region");
+        File file3 = new File(file2, "r." + (i >> 5) + "." + (j >> 5) + ".mca");
+        RegionFile regionfile = (RegionFile) a.get(file3);
+
+        if (regionfile != null) {
+            return regionfile;
+        } else {
+            if (!file2.exists()) {
+                file2.mkdirs();
+            }
+
+            if (a.size() >= 256) {
+                a();
+            }
+
+            RegionFile regionfile1 = new RegionFile(file3);
+
+            a.put(file3, regionfile1);
+            return regionfile1;
+        }
+    }
+
+    public static synchronized void a() {
+        Iterator iterator = a.values().iterator();
+
+        while (iterator.hasNext()) {
+            RegionFile regionfile = (RegionFile) iterator.next();
+
+            try {
+                if (regionfile != null) {
+                    regionfile.c();
+                }
+            } catch (IOException ioexception) {
+                ioexception.printStackTrace();
+            }
+        }
+
+        a.clear();
+    }
+
+    public static DataInputStream c(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.a(i & 31, j & 31);
+    }
+
+    public static DataOutputStream d(File file1, int i, int j) {
+        RegionFile regionfile = a(file1, i, j);
+
+        return regionfile.b(i & 31, j & 31);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
new file mode 100644
index 0000000..c2194af
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -0,0 +1,102 @@
+package net.minecraft.server;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+
+import net.minecraft.util.com.google.common.util.concurrent.ThreadFactoryBuilder;
+import net.minecraft.util.io.netty.bootstrap.ServerBootstrap;
+import net.minecraft.util.io.netty.channel.ChannelFuture;
+import net.minecraft.util.io.netty.channel.nio.NioEventLoopGroup;
+import net.minecraft.util.io.netty.channel.socket.nio.NioServerSocketChannel;
+import net.minecraft.util.io.netty.util.concurrent.GenericFutureListener;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerConnection {
+
+    private static final Logger b = LogManager.getLogger();
+    private static final NioEventLoopGroup c = new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty IO #%d").setDaemon(true).build());
+    private final MinecraftServer d;
+    public volatile boolean a;
+    private final List e = Collections.synchronizedList(new ArrayList());
+    private final List f = Collections.synchronizedList(new ArrayList());
+
+    public ServerConnection(MinecraftServer minecraftserver) {
+        this.d = minecraftserver;
+        this.a = true;
+    }
+
+    public void a(InetAddress inetaddress, int i) {
+        List list = this.e;
+
+        synchronized (this.e) {
+            this.e.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(NioServerSocketChannel.class)).childHandler(new ServerConnectionChannel(this)).group(c).localAddress(inetaddress, i)).bind().syncUninterruptibly());
+        }
+    }
+
+    public void b() {
+        this.a = false;
+        Iterator iterator = this.e.iterator();
+
+        while (iterator.hasNext()) {
+            ChannelFuture channelfuture = (ChannelFuture) iterator.next();
+
+            channelfuture.channel().close().syncUninterruptibly();
+        }
+    }
+
+    public void c() {
+        List list = this.f;
+
+        synchronized (this.f) {
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                NetworkManager networkmanager = (NetworkManager) iterator.next();
+
+                if (!networkmanager.isConnected()) {
+                    iterator.remove();
+                    if (networkmanager.f() != null) {
+                        networkmanager.getPacketListener().a(networkmanager.f());
+                    } else if (networkmanager.getPacketListener() != null) {
+                        networkmanager.getPacketListener().a(new ChatComponentText("Disconnected"));
+                    }
+                } else {
+                    try {
+                        networkmanager.a();
+                    } catch (Exception exception) {
+                        if (networkmanager.c()) {
+                            CrashReport crashreport = CrashReport.a(exception, "Ticking memory connection");
+                            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Ticking connection");
+
+                            crashreportsystemdetails.a("Connection", (Callable) (new CrashReportServerConnection(this, networkmanager)));
+                            throw new ReportedException(crashreport);
+                        }
+
+                        b.warn("Failed to handle packet for " + networkmanager.getSocketAddress(), exception);
+                        ChatComponentText chatcomponenttext = new ChatComponentText("Internal server error");
+
+                        networkmanager.handle(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener[] { new ServerConnectionFuture(this, networkmanager, chatcomponenttext)});
+                        networkmanager.g();
+                    }
+                }
+            }
+        }
+    }
+
+    public MinecraftServer d() {
+        return this.d;
+    }
+
+    static List a(ServerConnection serverconnection) {
+        return serverconnection.f;
+    }
+
+    static MinecraftServer b(ServerConnection serverconnection) {
+        return serverconnection.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerConnectionChannel.java b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
new file mode 100644
index 0000000..d7d93a0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerConnectionChannel.java
@@ -0,0 +1,37 @@
+package net.minecraft.server;
+
+import net.minecraft.util.io.netty.channel.Channel;
+import net.minecraft.util.io.netty.channel.ChannelException;
+import net.minecraft.util.io.netty.channel.ChannelInitializer;
+import net.minecraft.util.io.netty.channel.ChannelOption;
+import net.minecraft.util.io.netty.handler.timeout.ReadTimeoutHandler;
+
+class ServerConnectionChannel extends ChannelInitializer {
+
+    final ServerConnection a;
+
+    ServerConnectionChannel(ServerConnection serverconnection) {
+        this.a = serverconnection;
+    }
+
+    protected void initChannel(Channel channel) {
+        try {
+            channel.config().setOption(ChannelOption.IP_TOS, Integer.valueOf(24));
+        } catch (ChannelException channelexception) {
+            ;
+        }
+
+        try {
+            channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(false));
+        } catch (ChannelException channelexception1) {
+            ;
+        }
+
+        channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(this.a)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(NetworkManager.h)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(NetworkManager.h));
+        NetworkManager networkmanager = new NetworkManager(false);
+
+        ServerConnection.a(this.a).add(networkmanager);
+        channel.pipeline().addLast("packet_handler", networkmanager);
+        networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.b(this.a), networkmanager)));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ServerStatisticManager.java b/src/main/java/net/minecraft/server/ServerStatisticManager.java
new file mode 100644
index 0000000..0becb94
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ServerStatisticManager.java
@@ -0,0 +1,202 @@
+package net.minecraft.server;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Constructor;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.Map.Entry;
+
+import net.minecraft.util.com.google.common.collect.Maps;
+import net.minecraft.util.com.google.common.collect.Sets;
+import net.minecraft.util.com.google.gson.JsonElement;
+import net.minecraft.util.com.google.gson.JsonObject;
+import net.minecraft.util.com.google.gson.JsonParseException;
+import net.minecraft.util.com.google.gson.JsonParser;
+import net.minecraft.util.org.apache.commons.io.FileUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class ServerStatisticManager extends StatisticManager {
+
+    private static final Logger b = LogManager.getLogger();
+    private final MinecraftServer c;
+    private final File d;
+    private final Set e = Sets.newHashSet();
+    private int f = -300;
+    private boolean g = false;
+
+    public ServerStatisticManager(MinecraftServer minecraftserver, File file1) {
+        this.c = minecraftserver;
+        this.d = file1;
+    }
+
+    public void a() {
+        if (this.d.isFile()) {
+            try {
+                this.a.clear();
+                this.a.putAll(this.a(FileUtils.readFileToString(this.d)));
+            } catch (IOException ioexception) {
+                b.error("Couldn\'t read statistics file " + this.d, ioexception);
+            } catch (JsonParseException jsonparseexception) {
+                b.error("Couldn\'t parse statistics file " + this.d, jsonparseexception);
+            }
+        }
+    }
+
+    public void b() {
+        try {
+            FileUtils.writeStringToFile(this.d, a(this.a));
+        } catch (IOException ioexception) {
+            b.error("Couldn\'t save stats", ioexception);
+        }
+    }
+
+    public void setStatistic(EntityHuman entityhuman, Statistic statistic, int i) {
+        int j = statistic.d() ? this.getStatisticValue(statistic) : 0;
+
+        super.setStatistic(entityhuman, statistic, i);
+        this.e.add(statistic);
+        if (statistic.d() && j == 0 && i > 0) {
+            this.g = true;
+            if (this.c.as()) {
+                this.c.getPlayerList().sendMessage(new ChatMessage("chat.type.achievement", new Object[] { entityhuman.getScoreboardDisplayName(), statistic.j()}));
+            }
+        }
+    }
+
+    public Set c() {
+        HashSet hashset = Sets.newHashSet(this.e);
+
+        this.e.clear();
+        this.g = false;
+        return hashset;
+    }
+
+    public Map a(String s) {
+        JsonElement jsonelement = (new JsonParser()).parse(s);
+
+        if (!jsonelement.isJsonObject()) {
+            return Maps.newHashMap();
+        } else {
+            JsonObject jsonobject = jsonelement.getAsJsonObject();
+            HashMap hashmap = Maps.newHashMap();
+            Iterator iterator = jsonobject.entrySet().iterator();
+
+            while (iterator.hasNext()) {
+                Entry entry = (Entry) iterator.next();
+                Statistic statistic = StatisticList.getStatistic((String) entry.getKey());
+
+                if (statistic != null) {
+                    StatisticWrapper statisticwrapper = new StatisticWrapper();
+
+                    if (((JsonElement) entry.getValue()).isJsonPrimitive() && ((JsonElement) entry.getValue()).getAsJsonPrimitive().isNumber()) {
+                        statisticwrapper.a(((JsonElement) entry.getValue()).getAsInt());
+                    } else if (((JsonElement) entry.getValue()).isJsonObject()) {
+                        JsonObject jsonobject1 = ((JsonElement) entry.getValue()).getAsJsonObject();
+
+                        if (jsonobject1.has("value") && jsonobject1.get("value").isJsonPrimitive() && jsonobject1.get("value").getAsJsonPrimitive().isNumber()) {
+                            statisticwrapper.a(jsonobject1.getAsJsonPrimitive("value").getAsInt());
+                        }
+
+                        if (jsonobject1.has("progress") && statistic.l() != null) {
+                            try {
+                                Constructor constructor = statistic.l().getConstructor(new Class[0]);
+                                IJsonStatistic ijsonstatistic = (IJsonStatistic) constructor.newInstance(new Object[0]);
+
+                                ijsonstatistic.a(jsonobject1.get("progress"));
+                                statisticwrapper.a(ijsonstatistic);
+                            } catch (Throwable throwable) {
+                                b.warn("Invalid statistic progress in " + this.d, throwable);
+                            }
+                        }
+                    }
+
+                    hashmap.put(statistic, statisticwrapper);
+                } else {
+                    b.warn("Invalid statistic in " + this.d + ": Don\'t know what " + (String) entry.getKey() + " is");
+                }
+            }
+
+            return hashmap;
+        }
+    }
+
+    public static String a(Map map) {
+        JsonObject jsonobject = new JsonObject();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((StatisticWrapper) entry.getValue()).b() != null) {
+                JsonObject jsonobject1 = new JsonObject();
+
+                jsonobject1.addProperty("value", Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+
+                try {
+                    jsonobject1.add("progress", ((StatisticWrapper) entry.getValue()).b().a());
+                } catch (Throwable throwable) {
+                    b.warn("Couldn\'t save statistic " + ((Statistic) entry.getKey()).e() + ": error serializing progress", throwable);
+                }
+
+                jsonobject.add(((Statistic) entry.getKey()).name, jsonobject1);
+            } else {
+                jsonobject.addProperty(((Statistic) entry.getKey()).name, Integer.valueOf(((StatisticWrapper) entry.getValue()).a()));
+            }
+        }
+
+        return jsonobject.toString();
+    }
+
+    public void d() {
+        Iterator iterator = this.a.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            Statistic statistic = (Statistic) iterator.next();
+
+            this.e.add(statistic);
+        }
+    }
+
+    public void a(EntityPlayer entityplayer) {
+        int i = this.c.ak();
+        HashMap hashmap = Maps.newHashMap();
+
+        if (this.g || i - this.f > 300) {
+            this.f = i;
+            Iterator iterator = this.c().iterator();
+
+            while (iterator.hasNext()) {
+                Statistic statistic = (Statistic) iterator.next();
+
+                hashmap.put(statistic, Integer.valueOf(this.getStatisticValue(statistic)));
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public void updateStatistics(EntityPlayer entityplayer) {
+        HashMap hashmap = Maps.newHashMap();
+        Iterator iterator = AchievementList.e.iterator();
+
+        while (iterator.hasNext()) {
+            Achievement achievement = (Achievement) iterator.next();
+
+            if (this.a(achievement)) {
+                hashmap.put(achievement, Integer.valueOf(this.getStatisticValue(achievement)));
+                this.e.remove(achievement);
+            }
+        }
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutStatistic(hashmap));
+    }
+
+    public boolean e() {
+        return this.g;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/StructureGenerator.java b/src/main/java/net/minecraft/server/StructureGenerator.java
new file mode 100644
index 0000000..97308d0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/StructureGenerator.java
@@ -0,0 +1,219 @@
+package net.minecraft.server;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.Callable;
+
+public abstract class StructureGenerator extends WorldGenBase {
+
+    private PersistentStructure e;
+    protected Map d = new HashMap();
+
+    public StructureGenerator() {}
+
+    public abstract String a();
+
+    protected final void a(World world, int i, int j, int k, int l, Block[] ablock) {
+        this.a(world);
+        if (!this.d.containsKey(Long.valueOf(ChunkCoordIntPair.a(i, j)))) {
+            this.b.nextInt();
+
+            try {
+                if (this.a(i, j)) {
+                    StructureStart structurestart = this.b(i, j);
+
+                    this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                    this.a(i, j, structurestart);
+                }
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception preparing structure feature");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Feature being prepared");
+
+                crashreportsystemdetails.a("Is feature chunk", (Callable) (new CrashReportIsFeatureChunk(this, i, j)));
+                crashreportsystemdetails.a("Chunk location", String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Chunk pos hash", (Callable) (new CrashReportChunkPosHash(this, i, j)));
+                crashreportsystemdetails.a("Structure type", (Callable) (new CrashReportStructureType(this)));
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(World world, Random random, int i, int j) {
+        this.a(world);
+        int k = (i << 4) + 8;
+        int l = (j << 4) + 8;
+        boolean flag = false;
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(k, l, k + 15, l + 15)) {
+                structurestart.a(world, random, new StructureBoundingBox(k, l, k + 15, l + 15));
+                flag = true;
+                this.a(structurestart.e(), structurestart.f(), structurestart);
+            }
+        }
+
+        return flag;
+    }
+
+    public boolean b(int i, int j, int k) {
+        this.a(this.c);
+        return this.c(i, j, k) != null;
+    }
+
+    protected StructureStart c(int i, int j, int k) {
+        Iterator iterator = this.d.values().iterator();
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d() && structurestart.a().a(i, k, i, k)) {
+                Iterator iterator1 = structurestart.b().iterator();
+
+                while (iterator1.hasNext()) {
+                    StructurePiece structurepiece = (StructurePiece) iterator1.next();
+
+                    if (structurepiece.c().b(i, j, k)) {
+                        return structurestart;
+                    }
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean d(int i, int j, int k) {
+        this.a(this.c);
+        Iterator iterator = this.d.values().iterator();
+
+        StructureStart structurestart;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            structurestart = (StructureStart) iterator.next();
+        } while (!structurestart.d());
+
+        return structurestart.a().a(i, k, i, k);
+    }
+
+    public ChunkPosition getNearestGeneratedFeature(World world, int i, int j, int k) {
+        this.c = world;
+        this.a(world);
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+        long j1 = (long) (i >> 4) * l;
+        long k1 = (long) (k >> 4) * i1;
+
+        this.b.setSeed(j1 ^ k1 ^ world.getSeed());
+        this.a(world, i >> 4, k >> 4, 0, 0, (Block[]) null);
+        double d0 = Double.MAX_VALUE;
+        ChunkPosition chunkposition = null;
+        Iterator iterator = this.d.values().iterator();
+
+        ChunkPosition chunkposition1;
+        int l1;
+        int i2;
+        double d1;
+        int j2;
+
+        while (iterator.hasNext()) {
+            StructureStart structurestart = (StructureStart) iterator.next();
+
+            if (structurestart.d()) {
+                StructurePiece structurepiece = (StructurePiece) structurestart.b().get(0);
+
+                chunkposition1 = structurepiece.a();
+                i2 = chunkposition1.x - i;
+                l1 = chunkposition1.y - j;
+                j2 = chunkposition1.z - k;
+                d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                if (d1 < d0) {
+                    d0 = d1;
+                    chunkposition = chunkposition1;
+                }
+            }
+        }
+
+        if (chunkposition != null) {
+            return chunkposition;
+        } else {
+            List list = this.o_();
+
+            if (list != null) {
+                ChunkPosition chunkposition2 = null;
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    chunkposition1 = (ChunkPosition) iterator1.next();
+                    i2 = chunkposition1.x - i;
+                    l1 = chunkposition1.y - j;
+                    j2 = chunkposition1.z - k;
+                    d1 = (double) (i2 * i2 + l1 * l1 + j2 * j2);
+                    if (d1 < d0) {
+                        d0 = d1;
+                        chunkposition2 = chunkposition1;
+                    }
+                }
+
+                return chunkposition2;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    protected List o_() {
+        return null;
+    }
+
+    private void a(World world) {
+        if (this.e == null) {
+            this.e = (PersistentStructure) world.a(PersistentStructure.class, this.a());
+            if (this.e == null) {
+                this.e = new PersistentStructure(this.a());
+                world.a(this.a(), (PersistentBase) this.e);
+            } else {
+                NBTTagCompound nbttagcompound = this.e.a();
+                Iterator iterator = nbttagcompound.c().iterator();
+
+                while (iterator.hasNext()) {
+                    String s = (String) iterator.next();
+                    NBTBase nbtbase = nbttagcompound.get(s);
+
+                    if (nbtbase.getTypeId() == 10) {
+                        NBTTagCompound nbttagcompound1 = (NBTTagCompound) nbtbase;
+
+                        if (nbttagcompound1.hasKey("ChunkX") && nbttagcompound1.hasKey("ChunkZ")) {
+                            int i = nbttagcompound1.getInt("ChunkX");
+                            int j = nbttagcompound1.getInt("ChunkZ");
+                            StructureStart structurestart = WorldGenFactory.a(nbttagcompound1, world);
+
+                            if (structurestart != null) {
+                                this.d.put(Long.valueOf(ChunkCoordIntPair.a(i, j)), structurestart);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j, StructureStart structurestart) {
+        this.e.a(structurestart.a(i, j), i, j);
+        this.e.c();
+    }
+
+    protected abstract boolean a(int i, int j);
+
+    protected abstract StructureStart b(int i, int j);
+}
diff --git a/src/main/java/net/minecraft/server/WatchableObject.java b/src/main/java/net/minecraft/server/WatchableObject.java
new file mode 100644
index 0000000..678aa91
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WatchableObject.java
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class WatchableObject {
+
+    private final int a;
+    private final int b;
+    private Object c;
+    private boolean d;
+
+    public WatchableObject(int i, int j, Object object) {
+        this.b = j;
+        this.c = object;
+        this.a = i;
+        this.d = true;
+    }
+
+    public int a() {
+        return this.b;
+    }
+
+    public void a(Object object) {
+        this.c = object;
+    }
+
+    public Object b() {
+        return this.c;
+    }
+
+    public int c() {
+        return this.a;
+    }
+
+    public boolean d() {
+        return this.d;
+    }
+
+    public void a(boolean flag) {
+        this.d = flag;
+    }
+
+    static boolean a(WatchableObject watchableobject, boolean flag) {
+        return watchableobject.d = flag;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/WorldGenPackedIce2.java b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
new file mode 100644
index 0000000..c0db754
--- /dev/null
+++ b/src/main/java/net/minecraft/server/WorldGenPackedIce2.java
@@ -0,0 +1,101 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenPackedIce2 extends WorldGenerator {
+
+    public WorldGenPackedIce2() {}
+
+    public boolean a(World world, Random random, int i, int j, int k) {
+        while (world.isEmpty(i, j, k) && j > 2) {
+            --j;
+        }
+
+        if (world.getType(i, j, k) != Blocks.SNOW_BLOCK) {
+            return false;
+        } else {
+            j += random.nextInt(4);
+            int l = random.nextInt(4) + 7;
+            int i1 = l / 4 + random.nextInt(2);
+
+            if (i1 > 1 && random.nextInt(60) == 0) {
+                j += 10 + random.nextInt(30);
+            }
+
+            int j1;
+            int k1;
+            int l1;
+
+            for (j1 = 0; j1 < l; ++j1) {
+                float f = (1.0F - (float) j1 / (float) l) * (float) i1;
+
+                k1 = MathHelper.f(f);
+
+                for (l1 = -k1; l1 <= k1; ++l1) {
+                    float f1 = (float) MathHelper.a(l1) - 0.25F;
+
+                    for (int i2 = -k1; i2 <= k1; ++i2) {
+                        float f2 = (float) MathHelper.a(i2) - 0.25F;
+
+                        if ((l1 == 0 && i2 == 0 || f1 * f1 + f2 * f2 <= f * f) && (l1 != -k1 && l1 != k1 && i2 != -k1 && i2 != k1 || random.nextFloat() <= 0.75F)) {
+                            Block block = world.getType(i + l1, j + j1, k + i2);
+
+                            if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                this.setType(world, i + l1, j + j1, k + i2, Blocks.PACKED_ICE);
+                            }
+
+                            if (j1 != 0 && k1 > 1) {
+                                block = world.getType(i + l1, j - j1, k + i2);
+                                if (block.getMaterial() == Material.AIR || block == Blocks.DIRT || block == Blocks.SNOW_BLOCK || block == Blocks.ICE) {
+                                    this.setType(world, i + l1, j - j1, k + i2, Blocks.PACKED_ICE);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            j1 = i1 - 1;
+            if (j1 < 0) {
+                j1 = 0;
+            } else if (j1 > 1) {
+                j1 = 1;
+            }
+
+            for (int j2 = -j1; j2 <= j1; ++j2) {
+                k1 = -j1;
+
+                while (k1 <= j1) {
+                    l1 = j - 1;
+                    int k2 = 50;
+
+                    if (Math.abs(j2) == 1 && Math.abs(k1) == 1) {
+                        k2 = random.nextInt(5);
+                    }
+
+                    while (true) {
+                        if (l1 > 50) {
+                            Block block1 = world.getType(i + j2, l1, k + k1);
+
+                            if (block1.getMaterial() == Material.AIR || block1 == Blocks.DIRT || block1 == Blocks.SNOW_BLOCK || block1 == Blocks.ICE || block1 == Blocks.PACKED_ICE) {
+                                this.setType(world, i + j2, l1, k + k1, Blocks.PACKED_ICE);
+                                --l1;
+                                --k2;
+                                if (k2 <= 0) {
+                                    l1 -= random.nextInt(5) + 1;
+                                    k2 = random.nextInt(5);
+                                }
+                                continue;
+                            }
+                        }
+
+                        ++k1;
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+    }
+}
-- 
1.8.5.2.msysgit.0

